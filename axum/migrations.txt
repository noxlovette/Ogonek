CREATE TABLE "user" (
    id VARCHAR(21) PRIMARY KEY,
    name VARCHAR NOT NULL CHECK (LENGTH(name) >= 3),
    username VARCHAR NOT NULL,
    email VARCHAR NOT NULL,
    pass VARCHAR NOT NULL,
    role VARCHAR NOT NULL,
    verified BOOLEAN NOT NULL DEFAULT false,
    joined TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT user_username_key UNIQUE (username),
    CONSTRAINT user_email_key UNIQUE (email),
    CONSTRAINT email_format CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$')
);CREATE TABLE profile (
    user_id VARCHAR(21) PRIMARY KEY REFERENCES "user"(id) ON DELETE CASCADE,
    quizlet_url VARCHAR(255),
    bio TEXT,
    avatar_url VARCHAR(255),
    zoom_url VARCHAR(255),
    timezone VARCHAR(50),
    CONSTRAINT valid_quizlet_url CHECK (quizlet_url ~ '^https?:\/\/quizlet\.com\/.*$'),
    CONSTRAINT valid_zoom_url CHECK (zoom_url ~ '^https?:\/\/(?:[a-z0-9-]+\.)?zoom\.us\/j\/\d{9,11}(?:\?pwd=[a-zA-Z0-9]+)?$')
);

CREATE FUNCTION create_profile_for_user()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO profile (user_id)
    VALUES (NEW.id);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER create_profile_after_user_insert
    AFTER INSERT ON "user"
    FOR EACH ROW
    EXECUTE FUNCTION create_profile_for_user();CREATE TABLE lessons (
    id VARCHAR(21) PRIMARY KEY,
    markdown TEXT NOT NULL DEFAULT '#New Lesson',
    title VARCHAR(255) NOT NULL,
    topic VARCHAR(255) NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_by VARCHAR(21) NOT NULL REFERENCES "user"(id),
    assignee VARCHAR(21) NOT NULL REFERENCES "user"(id)
);

-- Create updated_at trigger function (if not exists)
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Add trigger to lessons
CREATE TRIGGER update_lessons_updated_at
    BEFORE UPDATE ON lessons
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();CREATE TABLE tasks (
    id VARCHAR(21) PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    markdown TEXT NOT NULL,
    priority SMALLINT NOT NULL DEFAULT 1 
        CHECK (priority >= 1 AND priority <= 3),
    completed BOOLEAN NOT NULL DEFAULT FALSE,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    due_date TIMESTAMP WITH TIME ZONE,
    file_path TEXT,
    created_by VARCHAR(21) NOT NULL REFERENCES "user"(id) ON DELETE CASCADE,
    assignee VARCHAR(21) NOT NULL REFERENCES "user"(id) ON DELETE CASCADE
);

-- Add trigger for updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_tasks_updated_at
    BEFORE UPDATE ON tasks
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();CREATE TABLE teacher_student (
    teacher_id VARCHAR(21) REFERENCES "user"(id) ON DELETE CASCADE,
    student_id VARCHAR(21) REFERENCES "user"(id) ON DELETE CASCADE,
    status VARCHAR(20) DEFAULT 'active',
    markdown TEXT,
    telegram_id VARCHAR(20),
    joined TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (teacher_id, student_id)
);

CREATE INDEX idx_teacher_student_notes 
    ON teacher_student 
    USING GIN (to_tsvector('english', markdown));CREATE TABLE student_notes (
    id VARCHAR(21) PRIMARY KEY,
    lesson_id VARCHAR(21) NOT NULL,
    user_id VARCHAR(21) NOT NULL,
    is_bookmarked BOOLEAN DEFAULT false,
    notes TEXT,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (lesson_id) REFERENCES lessons(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES "user"(id) ON DELETE CASCADE,
    CONSTRAINT unique_student_lesson_note UNIQUE (lesson_id, user_id)
);

CREATE INDEX idx_student_notes_lesson_user 
    ON student_notes(lesson_id, user_id);
CREATE TABLE decks (
    id VARCHAR(21) PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    created_by VARCHAR(21) NOT NULL REFERENCES "user"(id) ON DELETE CASCADE,
    shared BOOLEAN NOT NULL DEFAULT FALSE,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE cards (
    id VARCHAR(21) PRIMARY KEY,
    front TEXT NOT NULL,
    back TEXT NOT NULL,
    media_url TEXT,
    deck_id VARCHAR(21) NOT NULL REFERENCES decks(id) ON DELETE CASCADE,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE card_progress (
    id VARCHAR(21) PRIMARY KEY,
    user_id VARCHAR(21) NOT NULL REFERENCES "user"(id) ON DELETE CASCADE,
    card_id VARCHAR(21) NOT NULL REFERENCES cards(id) ON DELETE CASCADE,
    review_count INT NOT NULL DEFAULT 0, -- Number of reviews
    last_reviewed TIMESTAMP WITH TIME ZONE, -- Last review timestamp
    due_date TIMESTAMP WITH TIME ZONE, -- Next scheduled review
    ease_factor FLOAT NOT NULL DEFAULT 2.5, -- SR algorithm modifier
    interval INT NOT NULL DEFAULT 1, -- Days until next review
    CONSTRAINT unique_card_user UNIQUE (user_id, card_id)
);
-- Step 1: Add visibility column and assignee column
ALTER TABLE decks
ADD COLUMN visibility VARCHAR(20) NOT NULL DEFAULT 'private',
ADD COLUMN assignee VARCHAR(21) REFERENCES "user"(id) ON DELETE SET NULL,
ADD CONSTRAINT valid_visibility CHECK (visibility IN ('private', 'assigned', 'public'));

-- Step 2: Migrate data from shared to visibility
UPDATE decks 
SET visibility = CASE 
    WHEN shared = TRUE THEN 'public' 
    ELSE 'private' 
END;

-- Step 3: Drop the shared column
ALTER TABLE decks
DROP COLUMN shared;-- Optimized indices for lesson pagination
CREATE INDEX IF NOT EXISTS idx_lessons_created_at_id ON lessons(created_at DESC, id);
CREATE INDEX IF NOT EXISTS idx_lessons_assignee_created_at ON lessons(assignee, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_lessons_created_by_created_at ON lessons(created_by, created_at DESC);

-- Optimized indices for task pagination
CREATE INDEX IF NOT EXISTS idx_tasks_due_date_id ON tasks(due_date DESC, id);
CREATE INDEX IF NOT EXISTS idx_tasks_assignee_due_date ON tasks(assignee, due_date DESC);
CREATE INDEX IF NOT EXISTS idx_tasks_created_by_due_date ON tasks(created_by, due_date DESC);

-- Optimized indices for card progress pagination (for learning/flashcards)
CREATE INDEX IF NOT EXISTS idx_card_progress_user_due_date ON card_progress(user_id, due_date);

-- Add updated_at trigger if not already present
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Consider adding a counter cache for pagination efficiency
ALTER TABLE "user" ADD COLUMN IF NOT EXISTS lessons_count INTEGER DEFAULT 0;
ALTER TABLE "user" ADD COLUMN IF NOT EXISTS tasks_count INTEGER DEFAULT 0;

-- Create a function to update the lesson counts
CREATE OR REPLACE FUNCTION update_lesson_count()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        -- Update both assignee and creator counts
        UPDATE "user" SET lessons_count = lessons_count + 1 WHERE id = NEW.assignee;
        IF NEW.assignee != NEW.created_by THEN
            UPDATE "user" SET lessons_count = lessons_count + 1 WHERE id = NEW.created_by;
        END IF;
    ELSIF TG_OP = 'DELETE' THEN
        -- Update both assignee and creator counts
        UPDATE "user" SET lessons_count = lessons_count - 1 WHERE id = OLD.assignee;
        IF OLD.assignee != OLD.created_by THEN
            UPDATE "user" SET lessons_count = lessons_count - 1 WHERE id = OLD.created_by;
        END IF;
    END IF;
    
    RETURN NULL;
END;
$$ language 'plpgsql';

-- Create trigger for lessons
CREATE TRIGGER update_lesson_count_trigger
AFTER INSERT OR DELETE ON lessons
FOR EACH ROW EXECUTE FUNCTION update_lesson_count();

-- Create a function to update the task counts
CREATE OR REPLACE FUNCTION update_task_count()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        -- Update both assignee and creator counts
        UPDATE "user" SET tasks_count = tasks_count + 1 WHERE id = NEW.assignee;
        IF NEW.assignee != NEW.created_by THEN
            UPDATE "user" SET tasks_count = tasks_count + 1 WHERE id = NEW.created_by;
        END IF;
    ELSIF TG_OP = 'DELETE' THEN
        -- Update both assignee and creator counts
        UPDATE "user" SET tasks_count = tasks_count - 1 WHERE id = OLD.assignee;
        IF OLD.assignee != OLD.created_by THEN
            UPDATE "user" SET tasks_count = tasks_count - 1 WHERE id = OLD.created_by;
        END IF;
    END IF;
    
    RETURN NULL;
END;
$$ language 'plpgsql';

-- Create trigger for tasks
CREATE TRIGGER update_task_count_trigger
AFTER INSERT OR DELETE ON tasks
FOR EACH ROW EXECUTE FUNCTION update_task_count();

-- Populate the initial counts (run once after migration)
UPDATE "user" u SET 
    lessons_count = (
        SELECT COUNT(*) FROM lessons l 
        WHERE l.assignee = u.id OR l.created_by = u.id
    ),
    tasks_count = (
        SELECT COUNT(*) FROM tasks t 
        WHERE t.assignee = u.id OR t.created_by = u.id
    );